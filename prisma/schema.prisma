generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AgeGroup {
  U6
  U7
  U8
  U9
  U10
  U11
  U12
  U13
  U14
  U15
  U16
  U17
  U18
  U19
  HERREN
  UE32
  UE40
  UE50
  UE60
  DAMEN
  FREIZEITLIGA
}

enum AgeCategory {
  JUNIOREN
  JUNIORINNEN
  HERREN
  DAMEN
  FREIZEITLIGA
}

enum MatchType {
  TESTSPIEL
  LEISTUNGSVERGLEICH
}

enum Strength {
  SEHR_SCHWACH
  SCHWACH
  NORMAL
  STARK
  SEHR_STARK
  GRUPPE
  C_KLASSE
  B_KLASSE
  A_KLASSE
  KREISKLASSE
  KREISLIGA
  BEZIRKSLIGA
  BEZIRKSOBERLIGA
  LANDESLIGA
  FOERDERLIGA
  NLZ_LIGA
  BAYERNLIGA
  REGIONALLIGA
  DRITTE_LIGA
  ZWEITE_BUNDESLIGA
  ERSTE_BUNDESLIGA
}

enum PlayForm {
  FUNINO
  FUSSBALL_4
  FUSSBALL_5
  FUSSBALL_7
  NEUN_GEGEN_NEUN
  ELF_GEGEN_ELF
}

enum Level {
  BREITE
  MITTEL
  LEISTUNG
}

enum HomeAway {
  HOME
  AWAY
  FLEX
}

enum FieldType {
  FIELD
  TURF
  HALL
}

enum OfferStatus {
  OPEN
  MATCHED
  CLOSED
}

enum MatchStatus {
  PROPOSED
  CONFIRMED
  CANCELLED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELED
}

enum UserStatus {
  UNVERIFIED // frisch registriert, E-Mail noch nicht best√§tigt
  ACTIVE // E-Mail verifiziert
  PENDING // 24h Frist verstrichen -> pending bis erneute DOI
}

enum NotificationType {
  REQUEST_RECEIVED      // Jemand hat dein Angebot angefragt
  REQUEST_ACCEPTED      // Deine Anfrage wurde akzeptiert
  REQUEST_REJECTED      // Deine Anfrage wurde abgelehnt
  REQUEST_CANCELED      // Ein vereinbartes Spiel wurde abgesagt
  OFFER_UPDATED         // Ein gespeichertes Angebot wurde aktualisiert
  MATCH_CONFIRMED       // Spieltermin best√§tigt
  OFFER_AVAILABLE_AGAIN // Ein gemerktes Spiel wurde wieder freigegeben
}

model User {
  id    String @id @default(cuid())
  email String @unique

  username  String @unique // redundante Speicherung der E-Mail als Username
  firstName String
  lastName  String

  nickname String?
  phone    String?

  passwordHash String?
  otpCode      String?
  otpExpiresAt DateTime?

  emailVerifiedAt         DateTime?
  emailVerifyToken        String?
  emailVerifyTokenExpires DateTime?

  status UserStatus @default(UNVERIFIED)

  // üëá NEU: Einwilligungen
  privacyAcceptedAt    DateTime? // Pflicht beim Registrieren
  privacyPolicyVersion String? // optional, z. B. "v1.0"
  marketingOptInAt     DateTime? // optional

  teams    Team[]
  messages Message[]

  savedOffers SavedOffer[]

  requests  OfferRequest[]
  
  notificationsReceived Notification[]
  
  conversationsAsUser1 Conversation[] @relation("ConversationUser1")
  conversationsAsUser2 Conversation[] @relation("ConversationUser2")
  chatMessagesSent     ChatMessage[]  @relation("ChatMessageSender")
}

model Club {
  id     String  @id @default(cuid())
  name   String  @unique
  city   String?
  street String? // NEU: Adresse Stra√üe
  zip    String?

  // Optionales Vereinslogo
  logoUrl       String? // z.B. '/uploads/club-logos/<file>'
  logoMime      String? // 'image/png' | 'image/jpeg'
  logoWidth     Int?
  logoHeight    Int?
  logoUpdatedAt DateTime?

  // Meta
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lat    Float?
  lng    Float?
  teams  Team[]
  venues Venue[] // NEU
}

model Venue {
  id     String  @id @default(cuid())
  clubId String
  name   String
  street String?
  city   String?
  zip    String?

  club Club @relation(fields: [clubId], references: [id], onDelete: Cascade)

  lat       Float?
  lng       Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clubId, name])
  @@index([clubId])
}

model Team {
  id            String        @id @default(cuid())
  clubId        String
  contactUserId String
  ageGroup      AgeGroup
  ageCategory   AgeCategory?
  level         Level
  lat           Float?
  lng           Float?

  // NEU f√ºr Step 3:
  name          String?
  year          Int?
  preferredForm PlayForm?

  club        Club @relation(fields: [clubId], references: [id])
  contactUser User @relation(fields: [contactUserId], references: [id])

  offers      GameOffer[]
  matchesHome Match[]     @relation("HomeTeam")
  matchesAway Match[]     @relation("AwayTeam")

  @@index([ageGroup, level])

  requestsMade OfferRequest[] @relation("RequesterTeam")
}

model GameOffer {
  id     String @id @default(cuid())
  teamId String

  // ALT (l√§uft weiter, bis wir API/UI umstellen)
  dateStart    DateTime
  dateEnd      DateTime
  fixedKickoff DateTime?

  // NEU (sauber nach deinen Vorgaben)
  offerDate       DateTime? // nur Datum
  kickoffTime     String? // nur Uhrzeit als "HH:mm"
  kickoffFlexible Boolean   @default(false)
  strength        Strength? // Spielst√§rke
  playForm        PlayForm? // Spielform
  durationText    String? // Spielzeit (Freitext)

  // NEU: Zwei-stufige Altersklassen + Spielart
  ageCategory      AgeCategory?
  matchType        MatchType      @default(TESTSPIEL)
  numberOfOpponents Int?

  homeAway  HomeAway    @default(FLEX)
  fieldType FieldType   @default(FIELD)
  lat       Float?
  lng       Float?
  radiusKm  Int         @default(30)
  notes     String?
  status    OfferStatus @default(OPEN)
  isReserved Boolean    @default(false)
  createdAt DateTime    @default(now())

  team    Team    @relation(fields: [teamId], references: [id])
  matches Match[]

  // Altersklassen (ggf. mehrere) als eigene Relation
  ages OfferAge[]

  savedBy SavedOffer[]

  requests OfferRequest[]

  @@index([status, dateStart, dateEnd])
}

model OfferAge {
  id       String   @id @default(cuid())
  offerId  String
  ageGroup AgeGroup

  offer GameOffer @relation(fields: [offerId], references: [id])

  @@index([offerId, ageGroup])
}

model Match {
  id         String      @id @default(cuid())
  offerId    String
  homeTeamId String
  awayTeamId String
  kickoff    DateTime
  venueLat   Float?
  venueLng   Float?
  status     MatchStatus @default(PROPOSED)
  createdAt  DateTime    @default(now())

  offer    GameOffer @relation(fields: [offerId], references: [id])
  homeTeam Team      @relation("HomeTeam", fields: [homeTeamId], references: [id])
  awayTeam Team      @relation("AwayTeam", fields: [awayTeamId], references: [id])
  messages Message[]

  @@index([status, kickoff])
}

model Message {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  text      String
  createdAt DateTime @default(now())

  match  Match @relation(fields: [matchId], references: [id])
  author User  @relation(fields: [userId], references: [id])

  @@index([matchId, createdAt])
}

model GeoCache {
  id        String   @id @default(cuid())
  zip       String?
  city      String?
  street    String?
  lat       Float
  lng       Float
  provider  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([zip, city, street])
}

model SavedOffer {
  userId    String
  offerId   String
  createdAt DateTime @default(now())

  user  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  offer GameOffer @relation(fields: [offerId], references: [id], onDelete: Cascade)

  @@id([userId, offerId])
  @@index([offerId])
}

model OfferRequest {
  requesterUserId String
  offerId         String
  requesterTeamId String?
  message         String?
  status          RequestStatus @default(PENDING)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @default(now()) @updatedAt

  requesterUser User      @relation(fields: [requesterUserId], references: [id], onDelete: Cascade)
  offer         GameOffer @relation(fields: [offerId], references: [id], onDelete: Cascade)
  requesterTeam Team?     @relation(name: "RequesterTeam", fields: [requesterTeamId], references: [id])

  @@id([requesterUserId, offerId])
  @@index([offerId])
  @@index([status])
}

model Notification {
  id     String           @id @default(cuid())
  userId String
  type   NotificationType

  title   String
  message String?

  relatedOfferId     String?
  relatedRequesterId String?

  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read, createdAt])
  @@index([createdAt])
}

model Conversation {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1 User              @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User              @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  
  messages ChatMessage[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model ChatMessage {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  text           String
  read           Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
}
